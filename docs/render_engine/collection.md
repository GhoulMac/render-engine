Module render_engine.collection
===============================

Classes
-------

`Collection()`
:   

    ### Descendants

    * render_engine.blog.Blog

    ### Class variables

    `content_path`
    :   str(object='') -> str
        str(bytes_or_buffer[, encoding[, errors]]) -> str
        
        Create a new string object from the given object. If encoding or
        errors is specified, then the object must expose a data buffer
        that will be decoded using the given encoding and error handler.
        Otherwise, returns the result of object.__str__() (if defined)
        or repr(object).
        encoding defaults to sys.getdefaultencoding().
        errors defaults to 'strict'.

    `engine`
    :   Collection objects serve as a way to quickly process pages that have a
        LARGE portion of content that is similar or file driven.
        
        The most common form of collection would be a Blog, but can also be
        static pages that have their content stored in a dedicated file.
        
        Currently, collections must come from a content_path and all be the same
        content type.
        
        
        Example
        -------
        from render_engine import Collection
        
        @site.register_collection()
        class BasicCollection(Collection):
            pass
        
        
        Attributes
        ----------
        engine: str, optional
            The engine that the collection will pass to each page. Site's default
            engine
        template: str
            The template that each page will use to render
        routes: List[str]
            all routes that the file should be created at. default []
        content_path: List[PathString], optional
            the filepath to load content from.
        includes: List[str], optional
            the types of files in the content path that will be processed
            default ["*.md", "*.html"]
        has_archive: Bool
            if `True`, create an archive page with all of the processed pages saved
            as `pages`. default `False`
        _archive_template: str, optional
            template filename that will be used if `has_archive==True` default: archive.html"
        _archive_slug: str, optional
            slug for rendered page if `has_archive == True` default: all_posts
        _archive_content_type: Type[Page], optional
            content_type for the rendered archive page
        _archive_reverse: Bool, optional
            should the sorted `pages` be listed in reverse order. default: False

    `has_archive`
    :   bool(x) -> bool
        
        Returns True when the argument x is true, False otherwise.
        The builtins True and False are the only two instances of the class bool.
        The class bool is a subclass of the class int, and cannot be subclassed.

    `includes`
    :   Built-in mutable sequence.
        
        If no argument is given, the constructor creates a new empty list.
        The argument must be an iterable if specified.

    `page_content_type`
    :   Base component used to make web pages.
        
        All components that represent content in HTML, XML, or JSON generated by 
        Render Engine should be a Page object.
        
        Pages can be rendered directly from a template or from a file.
        
        Page objects can be used to extend existing page objects.
        
        
        Examples:
            ```
            # Basic Page with No Template Variables
            @site.register_route('basic_page.html')
            class BasicPage(Page):
                template = 'template_file.html' # user provided template
        
            # Basic Page with Variables
            @site.register_route('page_with_vars')
            class PageWithVars(Page):
                title = 'Site Title'
        
            # Page Loading from File
            @site.register_route('page_from_file')
            class PageFromFile(Page):
                content_path = 'index.md' # loaded from content path can be '.md' or '.html'
        
            # Page Inherited from Other Page
            @site.register_route('basic_page.html')
            class BasicPage(Page):
                template = 'template_file.html' # user provided template
                title = 'Base Page'
        
            @site.register_route('other_page.html')
            class InheritingPage(Page):
                # template will be inherited from the BasicPage
                title = 'Inherited Page'
            ```
        
        Attributes:
            engine: str, optional
                The engine that the Site should refer to or the site's default engine
            template: str
                The template that the Site should refer to. If empty, use site's default
            routes: List[str]
                all routes that the file should be created at. default []
            content_path: List[PathString], optional
                the filepath to load content from.
            slug: str
                The engine's default route filename
            content: str
                preprocessed text stripped from initialized content. This will not
                include any defined attrs
            html: str
                text converted to html from _content

    `routes`
    :   Built-in mutable sequence.
        
        If no argument is given, the constructor creates a new empty list.
        The argument must be an iterable if specified.

    `template`
    :   str(object='') -> str
        str(bytes_or_buffer[, encoding[, errors]]) -> str
        
        Create a new string object from the given object. If encoding or
        errors is specified, then the object must expose a data buffer
        that will be decoded using the given encoding and error handler.
        Otherwise, returns the result of object.__str__() (if defined)
        or repr(object).
        encoding defaults to sys.getdefaultencoding().
        errors defaults to 'strict'.

    ### Instance variables

    `archive`
    :   Create a `Page` object for those items

    `pages`
    :   Iterate through set of pages and generate a `Page`-like object for each.